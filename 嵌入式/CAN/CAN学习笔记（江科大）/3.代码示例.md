## 1. 单个设备环回测试

**main.c**
```cpp
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Key.h"
#include "MyCAN.h"

uint8_t KeyNum;
uint32_t TxID = 0x555;
uint8_t TxLength = 4;
uint8_t TxData[8] = {0x11, 0x22, 0x33, 0x44};

uint32_t RxID;
uint8_t RxLength;
uint8_t RxData[8];

int main(void)
{
    OLED_Init();
    Key_Init();
    MyCAN_Init();
    
    OLED_ShowString(1, 1, "TxID:");
    OLED_ShowHexNum(1, 6, TxID, 3);
    OLED_ShowString(2, 1, "RxID:");
    OLED_ShowString(3, 1, "Leng:");
    OLED_ShowString(4, 1, "Data:");
    
    while (1)
    {
        KeyNum = Key_GetNum();
        
        if (KeyNum == 1)
        {
            TxData[0] ++;
            TxData[1] ++;
            TxData[2] ++;
            TxData[3] ++;
            
            MyCAN_Transmit(TxID, TxLength, TxData);
        }
        
        if (MyCAN_ReceiveFlag())
        {
            MyCAN_Receive(&RxID, &RxLength, RxData);
            
            OLED_ShowHexNum(2, 6, RxID, 3);
            OLED_ShowHexNum(3, 6, RxLength, 1);
            OLED_ShowHexNum(4, 6, RxData[0], 2);
            OLED_ShowHexNum(4, 9, RxData[1], 2);
            OLED_ShowHexNum(4, 12, RxData[2], 2);
            OLED_ShowHexNum(4, 15, RxData[3], 2);
        }
    }
}

```

**MyCAN.h**

```cpp
#ifndef __MYCAN_H
#define __MYCAN_H

void MyCAN_Init(void);
void MyCAN_Transmit(uint32_t ID, uint8_t Length, uint8_t *Data);
uint8_t MyCAN_ReceiveFlag(void);
void MyCAN_Receive(uint32_t *ID, uint8_t *Length, uint8_t *Data);

#endif

```

**MyCAN.c**

```cpp
#include "stm32f10x.h"                  // Device header

void MyCAN_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //CanTx初始化为复用推挽模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;   //CanRx初始化为上拉输入
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    CAN_InitTypeDef CAN_InitStructure;
    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;     //环回模式
    CAN_InitStructure.CAN_Prescaler = 48;        //波特率 = 36M / 48 / (1 + 2 + 3) = 125K
    CAN_InitStructure.CAN_BS1 = CAN_BS1_2tq;    //指定BS1的tq数
    CAN_InitStructure.CAN_BS2 = CAN_BS2_3tq;    //指定BS2的tq数
    CAN_InitStructure.CAN_SJW = CAN_SJW_2tq;    //指定SJW的tq数，用于再同步，和计算波特率无关
    CAN_InitStructure.CAN_NART = DISABLE;       //不自动重传。DISABLE
    CAN_InitStructure.CAN_TXFP = DISABLE;       //发送邮箱优先级。ENABLE：先请求先发送；DISABLE：ID号小的先发送
    CAN_InitStructure.CAN_RFLM = DISABLE;       //FIFO锁定。ENABLE：FIFO溢出时，新报文丢弃；DISABLE：FIFO溢出时，最后收到的报文被新报文覆盖
    CAN_InitStructure.CAN_AWUM = DISABLE;       //自动唤醒。
    CAN_InitStructure.CAN_TTCM = DISABLE;       //时间触发通信模式
    CAN_InitStructure.CAN_ABOM = DISABLE;       //离线自动恢复
    CAN_Init(CAN1, &CAN_InitStructure);
    
    //初始化过滤器
    CAN_FilterInitTypeDef CAN_FilterInitStructure;
    CAN_FilterInitStructure.CAN_FilterNumber = 0;       //使用那个过滤器，范围0~13
    CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;      //FxR1寄存器的高十六位
    CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;       //FxR1寄存器的低十六位
    CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;  //FxR2寄存器的高十六位
    CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;   //FxR2寄存器的低十六位
    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;        //32位过滤器
    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;         //屏蔽模式
    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;    //通过此过滤器的报文进FIFO0
    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;                  //激活过滤器
    CAN_FilterInit(&CAN_FilterInitStructure);
}

void MyCAN_Transmit(uint32_t ID, uint8_t Length, uint8_t *Data)
{
    CanTxMsg TxMessage;
    TxMessage.StdId = ID;
    TxMessage.ExtId = ID;
    TxMessage.IDE = CAN_Id_Standard;        //CAN_ID_STD
    TxMessage.RTR = CAN_RTR_Data;
    TxMessage.DLC = Length;
    for (uint8_t i = 0; i < Length; i ++)
    {
        TxMessage.Data[i] = Data[i];
    }
    
    uint8_t TransmitMailbox = CAN_Transmit(CAN1, &TxMessage);
    
    uint32_t Timeout = 0;
    while (CAN_TransmitStatus(CAN1, TransmitMailbox) != CAN_TxStatus_Ok)
    {
        Timeout ++;
        if (Timeout > 100000)
        {
            break;
        }
    }
}

uint8_t MyCAN_ReceiveFlag(void)
{
    if (CAN_MessagePending(CAN1, CAN_FIFO0) > 0)
    {
        return 1;
    }
    return 0;
}

void MyCAN_Receive(uint32_t *ID, uint8_t *Length, uint8_t *Data)
{
    CanRxMsg RxMessage;
    CAN_Receive(CAN1, CAN_FIFO0, &RxMessage);
    
    if (RxMessage.IDE == CAN_Id_Standard)
    {
        *ID = RxMessage.StdId;
    }
    else
    {
        *ID = RxMessage.ExtId;
    }
    
    if (RxMessage.RTR == CAN_RTR_Data)
    {
        *Length = RxMessage.DLC;
        for (uint8_t i = 0; i < *Length; i ++)
        {
            Data[i] = RxMessage.Data[i];
        }
    }
    else        //收到遥控帧
    {
        //...
    }
}

```

## 2. 过滤器配置

**16位列表模式**  

```cpp
CAN_FilterInitTypeDef CAN_FilterInitStructure;
CAN_FilterInitStructure.CAN_FilterNumber = 0;
CAN_FilterInitStructure.CAN_FilterIdHigh = 0x234 << 5;
CAN_FilterInitStructure.CAN_FilterIdLow = 0x345 << 5;
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x567 << 5;
CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x000 << 5;
CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_16bit;
CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdList;
CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;
CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
CAN_FilterInit(&CAN_FilterInitStructure);
```

**16位屏蔽模式**  

```cpp
CAN_FilterInitTypeDef CAN_FilterInitStructure;
CAN_FilterInitStructure.CAN_FilterNumber = 0;

CAN_FilterInitStructure.CAN_FilterIdHigh = 0x200 << 5;
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = (0x700 << 5) | 0x10 | 0x8;

CAN_FilterInitStructure.CAN_FilterIdLow = 0x320 << 5;
CAN_FilterInitStructure.CAN_FilterMaskIdLow = (0x7F0 << 5) | 0x10 | 0x8;

CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_16bit;
CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;
CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
CAN_FilterInit(&CAN_FilterInitStructure);
```

**32位列表模式**  

```cpp
CAN_FilterInitTypeDef CAN_FilterInitStructure;
CAN_FilterInitStructure.CAN_FilterNumber = 0;

uint32_t ID1 = 0x123 << 21;
CAN_FilterInitStructure.CAN_FilterIdHigh = ID1 >> 16;
CAN_FilterInitStructure.CAN_FilterIdLow = ID1;

uint32_t ID2 = (0x12345678u << 3) | 0x4;
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = ID2 >> 16;
CAN_FilterInitStructure.CAN_FilterMaskIdLow = ID2;

CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdList;
CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;
CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
CAN_FilterInit(&CAN_FilterInitStructure);
```

**32位屏蔽模式**  

```cpp
CAN_FilterInitTypeDef CAN_FilterInitStructure;
CAN_FilterInitStructure.CAN_FilterNumber = 0;

uint32_t ID = (0x12345600u << 3) | 0x4;
CAN_FilterInitStructure.CAN_FilterIdHigh = ID >> 16;
CAN_FilterInitStructure.CAN_FilterIdLow = ID;

uint32_t Mask = (0x1FFFFF00u << 3) | 0x4 | 0x2;
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = Mask >> 16;
CAN_FilterInitStructure.CAN_FilterMaskIdLow = Mask;

CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;
CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
CAN_FilterInit(&CAN_FilterInitStructure);
```

## 3. 中断接收配置

```cpp
CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);        //使能FIFO0中断

NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

NVIC_InitTypeDef NVIC_InitStructure;
NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
NVIC_Init(&NVIC_InitStructure);

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    if (CAN_GetITStatus(CAN1, CAN_IT_FMP0) == SET)
    {
        CAN_Receive(CAN1, CAN_FIFO0, &MyCAN_RxMsg);     //调用接收函数会清CAN_IT_FMP0标志位，且只能通过这种方式清，
                                                        // 不能通过CAN_ClearITPendingBit清
        MyCAN_RxFlag = 1;
    }
}
```

## 4. 数据传输策略

**发送部分**  
**main.c**  
```cpp
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Key.h"
#include "MyCAN.h"
#include "Timer.h"

uint8_t KeyNum;

uint8_t TimingFlag;
uint8_t TriggerFlag;
uint8_t RequestFlag;

CanTxMsg TxMsg_Timing = {
    .StdId = 0x100,
    .ExtId = 0x00000000,
    .IDE = CAN_Id_Standard,
    .RTR = CAN_RTR_Data,
    .DLC = 4,
    .Data = {0x11, 0x22, 0x33, 0x44}
};

CanTxMsg TxMsg_Trigger = {
    .StdId = 0x200,
    .ExtId = 0x00000000,
    .IDE = CAN_Id_Standard,
    .RTR = CAN_RTR_Data,
    .DLC = 4,
    .Data = {0x11, 0x22, 0x33, 0x44}
};

CanTxMsg TxMsg_Request = {
    .StdId = 0x300,
    .ExtId = 0x00000000,
    .IDE = CAN_Id_Standard,
    .RTR = CAN_RTR_Data,
    .DLC = 4,
    .Data = {0x11, 0x22, 0x33, 0x44}
};

CanRxMsg RxMsg;

int main(void)
{
    OLED_Init();
    Key_Init();
    MyCAN_Init();
    Timer_Init();
    
    OLED_ShowString(1, 1, "Tx");
    OLED_ShowString(2, 1, "Tim:");
    OLED_ShowString(3, 1, "Tri:");
    OLED_ShowString(4, 1, "Req:");
    
    while (1)
    {
        /*定时发送*/
        if (TimingFlag == 1)
        {
            TimingFlag = 0;
            
            TxMsg_Timing.Data[0] ++;
            TxMsg_Timing.Data[1] ++;
            TxMsg_Timing.Data[2] ++;
            TxMsg_Timing.Data[3] ++;
            
            MyCAN_Transmit(&TxMsg_Timing);
            
            OLED_ShowHexNum(2, 5, TxMsg_Timing.Data[0], 2);
            OLED_ShowHexNum(2, 8, TxMsg_Timing.Data[1], 2);
            OLED_ShowHexNum(2, 11, TxMsg_Timing.Data[2], 2);
            OLED_ShowHexNum(2, 14, TxMsg_Timing.Data[3], 2);
        }
        
        /*触发发送*/
        KeyNum = Key_GetNum();
        if (KeyNum == 1)
        {
            TriggerFlag = 1;
        }
        
        if (TriggerFlag == 1)
        {
            TriggerFlag = 0;
            
            TxMsg_Trigger.Data[0] ++;
            TxMsg_Trigger.Data[1] ++;
            TxMsg_Trigger.Data[2] ++;
            TxMsg_Trigger.Data[3] ++;
            
            MyCAN_Transmit(&TxMsg_Trigger);
            
            OLED_ShowHexNum(3, 5, TxMsg_Trigger.Data[0], 2);
            OLED_ShowHexNum(3, 8, TxMsg_Trigger.Data[1], 2);
            OLED_ShowHexNum(3, 11, TxMsg_Trigger.Data[2], 2);
            OLED_ShowHexNum(3, 14, TxMsg_Trigger.Data[3], 2);
        }
        
        /*请求发送*/
        if (MyCAN_ReceiveFlag())
        {
            MyCAN_Receive(&RxMsg);
            
            if (RxMsg.IDE == CAN_Id_Standard &&
                RxMsg.RTR == CAN_RTR_Remote &&
                RxMsg.StdId == 0x300)
            {
                RequestFlag = 1;
            }
            
            if (RxMsg.IDE == CAN_Id_Standard &&
                RxMsg.RTR == CAN_RTR_Data &&
                RxMsg.StdId == 0x3FF)
            {
                RequestFlag = 1;
            }
        }
        
        if (RequestFlag == 1)
        {
            RequestFlag = 0;
            
            TxMsg_Request.Data[0] ++;
            TxMsg_Request.Data[1] ++;
            TxMsg_Request.Data[2] ++;
            TxMsg_Request.Data[3] ++;
            
            MyCAN_Transmit(&TxMsg_Request);
            
            OLED_ShowHexNum(4, 5, TxMsg_Request.Data[0], 2);
            OLED_ShowHexNum(4, 8, TxMsg_Request.Data[1], 2);
            OLED_ShowHexNum(4, 11, TxMsg_Request.Data[2], 2);
            OLED_ShowHexNum(4, 14, TxMsg_Request.Data[3], 2);
        }
    }
}

void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    {
        TimingFlag = 1;
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    }
}

```

**发送部分**  
**main.c**  

```cpp
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Key.h"
#include "MyCAN.h"

uint8_t KeyNum;

CanTxMsg TxMsg_Request_Remote = {
    .StdId = 0x300,
    .ExtId = 0x00000000,
    .IDE = CAN_Id_Standard,
    .RTR = CAN_RTR_Remote,
    .DLC = 0,
    .Data = {0x00}
};

CanTxMsg TxMsg_Request_Data = {
    .StdId = 0x3FF,
    .ExtId = 0x00000000,
    .IDE = CAN_Id_Standard,
    .RTR = CAN_RTR_Data,
    .DLC = 0,
    .Data = {0x00}
};

CanRxMsg RxMsg;

int main(void)
{
    OLED_Init();
    Key_Init();
    MyCAN_Init();
    
    OLED_ShowString(1, 1, "Rx");
    OLED_ShowString(2, 1, "Tim:");
    OLED_ShowString(3, 1, "Tri:");
    OLED_ShowString(4, 1, "Req:");
    
    while (1)
    {
        /*请求部分*/
        KeyNum = Key_GetNum();
        if (KeyNum == 1)
        {
            MyCAN_Transmit(&TxMsg_Request_Remote);
        }
        if (KeyNum == 2)
        {
            MyCAN_Transmit(&TxMsg_Request_Data);
        }
        
        /*接收部分*/
        if (MyCAN_ReceiveFlag())
        {
            MyCAN_Receive(&RxMsg);
            
            if (RxMsg.RTR == CAN_RTR_Data)
            {
                /*收到定时数据帧*/
                if (RxMsg.StdId == 0x100 && RxMsg.IDE == CAN_Id_Standard)
                {
                    OLED_ShowHexNum(2, 5, RxMsg.Data[0], 2);
                    OLED_ShowHexNum(2, 8, RxMsg.Data[1], 2);
                    OLED_ShowHexNum(2, 11, RxMsg.Data[2], 2);
                    OLED_ShowHexNum(2, 14, RxMsg.Data[3], 2);
                }
                
                /*收到触发数据帧*/
                if (RxMsg.StdId == 0x200 && RxMsg.IDE == CAN_Id_Standard)
                {
                    OLED_ShowHexNum(3, 5, RxMsg.Data[0], 2);
                    OLED_ShowHexNum(3, 8, RxMsg.Data[1], 2);
                    OLED_ShowHexNum(3, 11, RxMsg.Data[2], 2);
                    OLED_ShowHexNum(3, 14, RxMsg.Data[3], 2);
                }
                
                /*收到请求数据帧*/
                if (RxMsg.StdId == 0x300 && RxMsg.IDE == CAN_Id_Standard)
                {
                    OLED_ShowHexNum(4, 5, RxMsg.Data[0], 2);
                    OLED_ShowHexNum(4, 8, RxMsg.Data[1], 2);
                    OLED_ShowHexNum(4, 11, RxMsg.Data[2], 2);
                    OLED_ShowHexNum(4, 14, RxMsg.Data[3], 2);
                }
            }
        }
    }
}

```