<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>1&period;&#x6982;&#x8ff0;&#xff1a;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h2 id="1概述">1.概述：</h2>
<hr>
<p><strong>vector</strong>是一种可以改变大小的数组。</p>
<p>vector中的元素使用连续的存储位置，具有和数组一样高效的访问元素的方式。</p>
<p>当vector需要增加大小时，其会重新分配一个更大的空间，然后复制原来的内容至新空间。当然不会在每次插入元素时都这样做，因为这将耗费大量时间。当其空余位置较少时(size快接近capacity),才会重新分配空间。</p>
<p>vector以更多的内存换取了管理存储和动态增长的能力。而且其具有高效的元素访问效率，并且操作尾部元素也相对高效。但在其他位置插入、删除元素时效率较低。</p>
<blockquote>
<p>关于vector的详细信息，请参阅<a href="https://legacy.cplusplus.com/reference/vector/vector/">cplusplus.com</a></p>
</blockquote>
<h2 id="2类方法">2.类方法：</h2>
<hr>
<h3 id="21构造函数析构函数">2.1构造函数、析构函数：</h3>
<p><strong>构造函数</strong></p>
<table>
  <tbody>
    <tr>
      <td>类型</td>
      <td>函数声明</td>
      <td>示例</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>default</td>
      <td>vector (const allocator_type&amp; alloc = allocator_type());</td>
      <td>vector&lt;int&gt; first;</td>
      <td>空的int数组</td>
    </tr>
    <tr>
      <td>fill</td>
      <td><br>vector (size_type n, const value_type&amp; val = value_type(),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const allocator_type&amp; alloc = allocator_type());</td>
      <td>vector&lt;int&gt; second (4,100);</td>
      <td>4个int，值都为100</td>
    </tr>
    <tr>
      <td>range</td>
      <td><br>template &lt;class InputIterator&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vector (InputIterator first, InputIterator last,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const allocator_type&amp; alloc = allocator_type());</td>
      <td>vector&lt;int&gt;&nbsp; third (second.begin(),second.end());</td>
      <td>通过另一个序列容器构造</td>
    </tr>
    <tr>
      <td>copy</td>
      <td>vector (const vector&amp; x);</td>
      <td>vector&lt;int&gt; fourth (third);</td>
      <td>复制另一个vector的内容</td>
    </tr>
  </tbody>
  <colgroup>
    <col style="width: 12.5556%;">
    <col style="width: 48.4444%;">
    <col style="width: 16.2222%;">
    <col style="width: 22.7778%;">
  </colgroup>
</table>
<blockquote>
<p>次为c++98的标准，c++11起支持移动构造和列表初始化。<a href="https://legacy.cplusplus.com/reference/vector/vector/vector/">点此了解更多</a></p>
</blockquote>
<p><strong>析构函数</strong>
　<code>~vector();</code>销毁vector对象。</p>
<h3 id="22访问方式">2.2访问方式：</h3>
<table>
  <tbody>
    <tr>
      <td>函数</td>
      <td>示例：vector&lt;int&gt; myvector (10);</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>operator[]</td>
      <td>myvector[1] = 0;</td>
      <td>访问1号元素</td>
    </tr>
    <tr>
      <td>at</td>
      <td>myvector.at(1) = 0；</td>
      <td>访问1号元素</td>
    </tr>
    <tr>
      <td>front</td>
      <td>myvector.front()</td>
      <td>访问第一个元素</td>
    </tr>
    <tr>
      <td>back</td>
      <td>myvector.back()</td>
      <td>访问最后一个元素</td>
    </tr>
    <tr>
      <td>data</td>
      <td>int* p = myvector.data();</td>
      <td>返回指向第一个元素的指针</td>
    </tr>
  </tbody>
  <colgroup>
    <col>
    <col>
    <col>
  </colgroup>
</table>
<h3 id="23迭代器">2.3迭代器：</h3>
<table>
  <tbody>
    <tr>
      <td>函数</td>
      <td>示例：vector&lt;int&gt; myvector (10);</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>begin</td>
      <td>vector&lt;int&gt;::iterator it = myvector.begin()</td>
      <td>指向序列容器开头的迭代器。</td>
    </tr>
    <tr>
      <td>end</td>
      <td>vector&lt;int&gt;::iterator it = myvector.end()</td>
      <td>指向序列末尾之后的元素的迭代器。</td>
    </tr>
    <tr>
      <td>rbegin</td>
      <td>vector&lt;int&gt;::iterator it = myvector.rbegin()</td>
      <td>指向序列容器反向起始的反向迭代器。</td>
    </tr>
    <tr>
      <td>rend</td>
      <td>vector&lt;int&gt;::iterator it = myvector.rend()</td>
      <td>指向序列容器的反向末端的反向迭代器。</td>
    </tr>
    <tr>
      <td>cbegin</td>
      <td>vector&lt;int&gt;::iterator it = myvector.cbegin()</td>
      <td>指向序列容器开头的const迭代器。</td>
    </tr>
    <tr>
      <td>cend</td>
      <td>vector&lt;int&gt;::iterator it = myvector.cend()</td>
      <td>指向序列末尾之后的元素的const迭代器。</td>
    </tr>
    <tr>
      <td>crbegin</td>
      <td>vector&lt;int&gt;::iterator it = myvector.crbegin()</td>
      <td>指向序列反向起始的const反向迭代器。</td>
    </tr>
    <tr>
      <td>crend</td>
      <td>vector&lt;int&gt;::iterator it = myvector.crend()</td>
      <td>指向序列反向末端的const反向迭代器。</td>
    </tr>
  </tbody>
  <colgroup>
    <col style="width: 21.1111%;">
    <col style="width: 43.1111%;">
    <col style="width: 35.7778%;">
  </colgroup>
</table>
<blockquote>
<p>正向迭代器遍历vector<code>for (it = myvector.begin() ; it != myvector.end(); ++it)</code>将得到vector的正向序列。
反向迭代器遍历vector<code>for (it = myvector.rbegin() ; it != myvector.rend(); ++it)</code>将得到vector的反向序列。
对迭代器解引用<code>*it</code>将得到迭代器指向的元素。</p>
</blockquote>
<h3 id="24与大小相关的">2.4与大小相关的：</h3>
<table>
  <tbody>
    <tr>
      <td>函数</td>
      <td>函数声明</td>
      <td>示例：vector&lt;int&gt; myvector (10);</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>size</td>
      <td>size_type size() const;</td>
      <td>myvector.size()</td>
      <td>返回vector中实际元素的数量</td>
    </tr>
    <tr>
      <td>max_size</td>
      <td>size_type max_size() const;</td>
      <td>myvector.max_size()</td>
      <td>返回vector所能容纳的最大元素数</td>
    </tr>
    <tr>
      <td>resize</td>
      <td>void resize (size_type n, value_type val = value_type());</td>
      <td>myvector.resize(8)；<br>myvector.resize(8,100);</td>
      <td>调整容器大小使之包含n个元素</td>
    </tr>
    <tr>
      <td>capacity</td>
      <td>size_type capacity() const;</td>
      <td>myvector.capacity()</td>
      <td>返回已分配的存储容量大小</td>
    </tr>
    <tr>
      <td>empty</td>
      <td>bool empty() const;</td>
      <td>myvector.empty()</td>
      <td>检测vector是否为空</td>
    </tr>
    <tr>
      <td>reverse</td>
      <td>void reserve (size_type n);</td>
      <td>myvector.reverse(100)</td>
      <td>请求更改容量</td>
    </tr>
    <tr>
      <td>shirk_to_fit</td>
      <td>void shrink_to_fit();</td>
      <td>myvector.shirk_to_fit()</td>
      <td>请求容器减少其容量以适合其大小。</td>
    </tr>
  </tbody>
  <colgroup>
    <col style="width: 12.2222%;">
    <col style="width: 25.8889%;">
    <col style="width: 27.8889%;">
    <col style="width: 34%;">
  </colgroup>
</table>
<h3 id="25修改">2.5修改：</h3>
<table>
  <tbody>
    <tr>
      <td>函数</td>
      <td>函数声明</td>
      <td>示例：vector&lt;int&gt; myvector (10);</td>
      <td>说明</td>
    </tr>
    <tr>
      <td>assign</td>
      <td><br>template &lt;class InputIterator&gt;<br>&nbsp; void assign (InputIterator first, InputIterator last);</td>
      <td><br>myvector.assign (it,&nbsp; it+5);<br></td>
      <td>将迭代器指向的区间&nbsp; [it,&nbsp; it+5)&nbsp; 赋值给myvector</td>
    </tr>
    <tr>
      <td></td>
      <td>void assign (size_type n, const value_type&amp; val);</td>
      <td>myvector.assign (7,100);</td>
      <td>给myvector赋值7个100</td>
    </tr>
    <tr>
      <td>push_back</td>
      <td>void push_back (const value_type&amp; val);</td>
      <td>myvector.push_back(1)</td>
      <td>在末尾添加元素1</td>
    </tr>
    <tr>
      <td>pop_back</td>
      <td>void pop_back ();</td>
      <td><br>myvector.pop_back()</td>
      <td>删除最后一个元素</td>
    </tr>
    <tr>
      <td>insert</td>
      <td>iterator insert (iterator position, const value_type&amp; val);</td>
      <td>auto it = myvector.insert ( &nbsp;it, 200 );</td>
      <td>在位置it之前插入200</td>
    </tr>
    <tr>
      <td></td>
      <td>void insert (iterator position, size_type n, const value_type&amp; val);</td>
      <td>myvector.insert (it,2,300);</td>
      <td>在位置it之前插入2个300</td>
    </tr>
    <tr>
      <td></td>
      <td><br>template &lt;class InputIterator&gt;<br>&nbsp; &nbsp; void insert (iterator position, InputIterator first, InputIterator last);</td>
      <td>myvector.insert (it,first.begin(),first.end());</td>
      <td>在位置it之前插入<br>[&nbsp; &nbsp;first.begin(),first.end()&nbsp; )之间的元素</td>
    </tr>
    <tr>
      <td>erase</td>
      <td>iterator erase (iterator position);</td>
      <td>myvector.erase(it)</td>
      <td>删除位置it的元素</td>
    </tr>
    <tr>
      <td></td>
      <td>iterator erase (iterator first, iterator last);</td>
      <td>myvector.erase(it，it+5)</td>
      <td>删除区间&nbsp; [it，it+5)&nbsp; 之间的元素</td>
    </tr>
    <tr>
      <td>swap</td>
      <td>void swap (vector&amp; x);</td>
      <td>myvector.swap(first)</td>
      <td>交换myvector和first的内容</td>
    </tr>
    <tr>
      <td>clear</td>
      <td>void clear();</td>
      <td>myvector.clear()</td>
      <td>从vector中移除所有元素(这些元素被销毁)，使容器的大小为0。</td>
    </tr>
    <tr>
      <td>emplace</td>
      <td><br>template &lt;class... Args&gt;<br>iterator emplace (const_iterator position, Args&amp;&amp;... args);</td>
      <td>myvector.emplace ( it, 200 );</td>
      <td>就地构造元素并插入</td>
    </tr>
    <tr>
      <td>emplace_back</td>
      <td><br>template &lt;class... Args&gt;<br>&nbsp; void emplace_back (Args&amp;&amp;... args);</td>
      <td>myvector.emplace ( 200 );</td>
      <td>构造并在末尾插入元素</td>
    </tr>
  </tbody>
  <colgroup>
    <col style="width: 13.5556%;">
    <col style="width: 24.5556%;">
    <col style="width: 29.3333%;">
    <col style="width: 32.5556%;">
  </colgroup>
</table>
<blockquote>
<p>emplace和emplace_back要比insert和push_back效率高一点，因为少了<strong>拷贝副本</strong>及<strong>类型转换</strong>的时间。</p>
</blockquote>
<h3 id="26重载的一些运算符">2.6重载的一些运算符</h3>
<table>
  <tbody>
    <tr>
      <td>操作符</td>
      <td>含义</td>
    </tr>
    <tr>
      <td>==</td>
      <td>size相等且相应位置的元素相等则为真</td>
    </tr>
    <tr>
      <td>！=</td>
      <td>size不等或相应位置的元素存在不等则为真</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>按相应位置从前往后比较，以第一个不等的相应位置的元素大小关系为准</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>按相应位置从前往后比较，以第一个不等的相应位置的元素大小关系为准</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>按相应位置从前往后比较，以第一个不等的相应位置的元素大小关系为准</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>按相应位置从前往后比较，以第一个不等的相应位置的元素大小关系为准</td>
    </tr>
  </tbody>
  <colgroup>
    <col style="width: 35.7778%;">
    <col style="width: 64.1111%;">
  </colgroup>
</table>

            
            
        </body>
        </html>